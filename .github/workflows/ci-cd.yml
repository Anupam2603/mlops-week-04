name: CI-CD Pipeline for Iris API

on:
  push:
    branches: [ "main", "dev", "master" ]
  pull_request:
    branches: [ "main", "dev", "master" ]
  workflow_dispatch: # Allows manual running

# 2. Global ENVIRONMENT Variables (PLACEHOLDERS)
env:
  GCP_PROJECT_ID: stunning-agency-472702-a0
  GKE_CLUSTER_NAME: autopilot-cluster-1
  GKE_REGION: us-central1
  ARTIFACT_REGISTRY: iris-api-repo
  DEPLOYMENT_NAME: "iris-api-deployment"
  IMAGE_NAME: iris-api
# ----------------------------

# 3. The JOBS
jobs:
  # --- JOB 1: Continuous Integration (CI) ---
  # This job runs pytest to make sure our code is good.
  test:
    name: Run Pytest
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Run Pytest
        env:
          # Give the test script the secret URI
          MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
        run: pytest

  # --- JOB 2: Continuous Deployment (CD) ---
  # This job only runs if the 'test' job succeeds.
  build-and-deploy:
    name: Build and Deploy to GKE
    needs: test
    runs-on: ubuntu-latest

    # Add permissions for GCP authentication
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # 1. Authenticate to Google Cloud
      - name: Authenticate to GCP
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CD_SERVICE_ACCOUNT_KEY }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'

      # 2. Install GKE Auth Plugin
      - name: Install gke-gcloud-auth-plugin
        run: gcloud components install gke-gcloud-auth-plugin

      # 3. Configure Docker
      - name: Configure Docker to push to Artifact Registry
        run: gcloud auth configure-docker ${{ env.GKE_REGION }}-docker.pkg.dev

      # 4. Build the Docker Image
      - name: Build Docker image
        run: |
          docker build \
            --tag ${{ env.GKE_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            .

      # 5. Push the Docker Image
      - name: Push Docker image to Artifact Registry
        run: |
          docker push ${{ env.GKE_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      # 6. Connect to GKE Cluster
      - name: Get GKE cluster credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME }} \
          --region ${{ env.GKE_REGION }}

      # 7. Deploy to GKE
      - name: Deploy to GKE
        run: |
          # --- This is the "magic" ---
          # 1. Find and replace the 'image:' placeholder
          sed -i 's|image: .*|image: ${{ env.GKE_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/${{ env.IMAGE_NAME }}:latest|' k8s/deployment.yml
          
          # 2. Find and replace the 'MLFLOW_URI_PLACEHOLDER'
          sed -i 's|MLFLOW_URI_PLACEHOLDER|${{ secrets.MLFLOW_TRACKING_URI }}|' k8s/deployment.yml
          
          # 3. Apply the "instruction manuals"
          kubectl apply -f k8s/deployment.yml
          kubectl apply -f k8s/service.yml
          
          # --- THIS IS THE NEW LINE ---
          # 4. Apply the NEW Horizontal Pod Autoscaler
          kubectl apply -f k8s/hpa.yml

  # --- THIS IS THE NEW JOB ---
  # --- JOB 3: Stress Test (CD) ---
  # This job runs *after* deployment to stress test the API
  stress-test:
    name: Run Stress Test with wrk
    # This job MUST run after the 'build-and-deploy' job
    needs: build-and-deploy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # 1. We need to log in to GCP so we can use kubectl
      - name: Authenticate to GCP
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CD_SERVICE_ACCOUNT_KEY }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: Install gke-gcloud-auth-plugin
        run: gcloud components install gke-gcloud-auth-plugin

      # 2. Connect to the GKE cluster (just like the deploy job)
      - name: Get GKE cluster credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME }} \
          --region ${{ env.GKE_REGION }}
      
      # 3. Install the 'wrk' tool
      - name: Install wrk
        run: sudo apt-get update && sudo apt-get install -y wrk

      # 4. Get the API's Public IP Address
      # This loop waits up to 2 minutes for the Load Balancer to get an IP
      - name: Get API Public IP
        id: get_ip
        run: |
          echo "Waiting for Load Balancer IP..."
          for i in {1..12}; do
            IP=$(kubectl get service iris-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$IP" ]; then
              echo "IP found: $IP"
              echo "SERVICE_IP=$IP" >> $GITHUB_OUTPUT
              break
            fi
            echo "Still waiting..."
            sleep 10
          done
          if [ -z "$IP" ]; then
            echo "Load Balancer IP not found after 2 minutes."
            exit 1
          fi

      # 5. Run the Stress Test!
      # We hit the '/' endpoint (the health check)
      # -t4 = 4 threads
      # -c1000 = 1000 concurrent connections
      # -d30s = run for 30 seconds
      - name: Run wrk stress test (1000 connections)
        run: |
          echo "Running stress test on http://${{ steps.get_ip.outputs.SERVICE_IP }}/"
          wrk -t4 -c1000 -d90s http://${{ steps.get_ip.outputs.SERVICE_IP }}/
